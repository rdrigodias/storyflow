
import React, { useState } from 'react';
import JSZip from 'jszip';
import { Header } from './components/Header';
import { InputForm } from './components/InputForm';
import { SceneDisplay } from './components/SceneDisplay';
import { generateStoryboard, regenerateSceneImage } from './services/geminiService';
import { generateVideoFromScenes } from './services/videoService';
import type { Scene, CharacterInput, CharacterReference, AllCharactersInfo } from './types';
import { fileToBase64 } from './utils/fileUtils';

export function StoryboardCore() {
  const [scenes, setScenes] = useState<Scene[]>([]);
  const [isLoading, setIsLoading] = useState(false);
  
  // State for ZIP generation
  const [isZipping, setIsZipping] = useState(false);
  const [zipProgress, setZipProgress] = useState(0);
  
  const [loadingMessage, setLoadingMessage] = useState('');
  const [error, setError] = useState<string | null>(null);

  // State for video generation
  const [isSrtSource, setIsSrtSource] = useState(false);
  const [isRenderingVideo, setIsRenderingVideo] = useState(false);
  const [renderProgress, setRenderProgress] = useState(0); // 0 to 100
  const [renderingMessage, setRenderingMessage] = useState('');
  const [videoResolution, setVideoResolution] = useState<'720p' | '1080p'>('720p');
  const [videoUrl, setVideoUrl] = useState<string | null>(null);
  const [videoFilename, setVideoFilename] = useState<string | null>(null);
  const [audioUrl, setAudioUrl] = useState<string | null>(null);

  // State for regeneration
  const [characterReferences, setCharacterReferences] = useState<CharacterReference[]>([]);
  const [allCharactersInfo, setAllCharactersInfo] = useState<AllCharactersInfo>([]);
  const [imageStyle, setImageStyle] = useState<string>('Filme Realista');
  const [restrictionPrompt, setRestrictionPrompt] = useState<string>('');
  const [userApiKey, setUserApiKey] = useState<string | null>(null); // Armazena a chave do usu√°rio
  
  // State for batch actions
  const [selectedScenes, setSelectedScenes] = useState<Set<number>>(new Set());
  const [isBatchRegenerating, setIsBatchRegenerating] = useState(false);

  const handleGenerate = async (characters: CharacterInput[], script: string, srtContent: string | null, audioFile: File | null, style: string, restriction: string, generationDelay: number, pacing: number, customApiKey: string | null) => {
    // Reset state for a new request
    setIsLoading(true);
    setError(null);
    setScenes([]);
    setVideoUrl(null); 
    setVideoFilename(null);
    setRenderProgress(0);
    setZipProgress(0);
    setSelectedScenes(new Set());
    setImageStyle(style); // Store selected style
    setRestrictionPrompt(restriction); // Store restriction prompt
    setUserApiKey(customApiKey); // Store custom API key
    if (audioUrl) {
      URL.revokeObjectURL(audioUrl); // Clean up previous audio URL
      setAudioUrl(null);
    }
    
    setIsSrtSource(!!srtContent); 
    setLoadingMessage("Processando imagens de refer√™ncia...");

    try {
      // Handle audio file
      if (audioFile) {
        setAudioUrl(URL.createObjectURL(audioFile));
      }
      
      // Store all character info for context in regeneration and description generation
      const allChars: AllCharactersInfo = characters.map(c => ({
          name: c.name,
          characteristic: c.characteristic,
          context: c.context
      }));
      setAllCharactersInfo(allChars);


      // References for characters that have an image file for consistent generation
      const charRefs: CharacterReference[] = await Promise.all(
        characters
          .filter(char => char.file) // Only process characters with a file
          .map(async (char) => {
            // char.file is guaranteed to exist here due to the filter
            const base64Image = await fileToBase64(char.file!);
            return {
              name: char.name,
              base64Image,
              mimeType: char.file!.type,
              characteristic: char.characteristic,
              context: char.context
            };
          })
      );
      setCharacterReferences(charRefs); // Store for regeneration

      const generatedScenes = await generateStoryboard(
        charRefs, 
        allChars,
        srtContent ?? script, 
        !!srtContent,
        style,
        restriction,
        (message) => {
          setLoadingMessage(message);
        },
        generationDelay,
        pacing, // Pass the pacing value
        customApiKey // Pass the custom API key
      );
      setScenes(generatedScenes);

    } catch (err) {
      console.error(err);
      setError(err instanceof Error ? err.message : 'Ocorreu um erro desconhecido.');
    } finally {
      setIsLoading(false);
      setLoadingMessage('');
    }
  };

  const handleRegenerateScene = async (sceneNumber: number, newVisualDescription: string) => {
    const sceneIndex = scenes.findIndex(s => s.sceneNumber === sceneNumber);
    if (sceneIndex === -1) return;

    // Set loading state for the specific scene
    setScenes(prevScenes =>
      prevScenes.map(s =>
        s.sceneNumber === sceneNumber ? { ...s, isRegenerating: true, visualDescription: newVisualDescription } : s
      )
    );

    try {
      const newImageUrl = await regenerateSceneImage(
        newVisualDescription,
        characterReferences, // Use stored references with images
        allCharactersInfo, // Use all character info for context
        imageStyle, // Use stored style
        restrictionPrompt, // Use stored restriction prompt
        userApiKey // Use the stored user API key (if any)
      );

      // Update the scene with the new image
      setScenes(prevScenes =>
        prevScenes.map(s =>
          s.sceneNumber === sceneNumber ? { ...s, imageUrl: newImageUrl, isRegenerating: false } : s
        )
      );
    } catch (err) {
      console.error(`Falha ao regenerar a cena ${sceneNumber}:`, err);
      // Optionally show a temporary error message on the scene card
      alert(`N√£o foi poss√≠vel regenerar a imagem para a cena ${sceneNumber}. Tente novamente.`);
      // Reset loading state on error
      setScenes(prevScenes =>
        prevScenes.map(s =>
          s.sceneNumber === sceneNumber ? { ...s, isRegenerating: false } : s
        )
      );
    }
  };
  
  const handleDeleteSceneImage = (sceneNumber: number) => {
    const placeholder = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 200 112.5'%3E%3Crect width='200' height='112.5' fill='%231f2937'/%3E%3C/svg%3E";
    setScenes(prevScenes =>
      prevScenes.map(s => s.sceneNumber === sceneNumber ? { ...s, imageUrl: placeholder } : s)
    );
  };

  const handleUpdateSceneImage = async (sceneNumber: number, file: File) => {
    try {
        // Convert the new file to base64 immediately for display
        const reader = new FileReader();
        reader.readAsDataURL(file);
        reader.onload = () => {
             if (typeof reader.result === 'string') {
                 setScenes(prevScenes =>
                    prevScenes.map(s => s.sceneNumber === sceneNumber ? { ...s, imageUrl: reader.result as string } : s)
                );
             }
        };
    } catch (error) {
        setError("N√£o foi poss√≠vel carregar a imagem.");
    }
  };

  const handleSceneSelection = (sceneNumber: number) => {
    setSelectedScenes(prev => {
      const next = new Set(prev);
      if (next.has(sceneNumber)) next.delete(sceneNumber);
      else next.add(sceneNumber);
      return next;
    });
  };

  const handleSelectAll = () => {
    if (selectedScenes.size === scenes.length) setSelectedScenes(new Set());
    else setSelectedScenes(new Set(scenes.map(s => s.sceneNumber)));
  };

  const handleRegenerateSelected = async () => {
      if (selectedScenes.size === 0 || isBatchRegenerating) return;
      setIsBatchRegenerating(true);
      const scenesToRegenerate = scenes.filter(s => selectedScenes.has(s.sceneNumber));
      // Execute sequentially to avoid rate limits
      for(let i = 0; i < scenesToRegenerate.length; i++) {
        await handleRegenerateScene(scenesToRegenerate[i].sceneNumber, scenesToRegenerate[i].visualDescription);
        if (i < scenesToRegenerate.length - 1) {
             // Small pause between batch requests
             await new Promise(resolve => setTimeout(resolve, 1000));
        }
      }
      setIsBatchRegenerating(false);
  };
  
  const handleDownloadZip = async (sceneNumbersToDownload?: Set<number>) => {
    const scenesToDownload = sceneNumbersToDownload
      ? scenes.filter(s => sceneNumbersToDownload.has(s.sceneNumber))
      : scenes;
      
    if (scenesToDownload.length === 0 || isZipping) return;

    setIsZipping(true);
    setZipProgress(0);
    setError(null);

    try {
      const zip = new JSZip();
      
      // Phase 1: Downloading images (0% to 50%)
      const totalImages = scenesToDownload.length;
      let processedImages = 0;

      const imagePromises = scenesToDownload.map(async (scene) => {
        const response = await fetch(scene.imageUrl);
        const blob = await response.blob();
        
        // INTELLIGENT EXTENSION DETECTION
        // Determines extension based on actual MIME type, not string parsing
        let extension = 'jpg';
        if (blob.type === 'image/png') extension = 'png';
        else if (blob.type === 'image/svg+xml') extension = 'svg';
        else if (blob.type === 'image/jpeg') extension = 'jpg';
        
        const filename = `cena-${scene.sceneNumber}.${extension}`;
        
        processedImages++;
        const currentProgress = Math.round((processedImages / totalImages) * 50);
        setZipProgress(currentProgress);
        
        return { filename, blob };
      });
      
      const images = await Promise.all(imagePromises);
      
      images.forEach(({ filename, blob }) => {
        zip.file(filename, blob);
      });

      // Phase 2: Compressing (50% to 100%)
      const content = await zip.generateAsync({ 
          type: 'blob',
          compression: "DEFLATE",
          compressionOptions: { level: 6 } 
      }, (metadata) => {
          // Map metadata.percent (0-100) to our second half (50-100)
          setZipProgress(50 + Math.round(metadata.percent / 2));
      });

      const link = document.createElement('a');
      link.href = URL.createObjectURL(content);
      link.download = sceneNumbersToDownload ? `storyboard-selecao.zip` : 'storyboard.zip';
      document.body.appendChild(link);
      link.click();
      
      document.body.removeChild(link);
      URL.revokeObjectURL(link.href);
      setZipProgress(100);

    } catch (err) {
      console.error("Falha ao criar o arquivo zip:", err);
      setError(err instanceof Error ? err.message : 'Falha ao criar o arquivo ZIP.');
    } finally {
      setTimeout(() => setIsZipping(false), 1000); // Small delay to show 100%
    }
  };

  const handleGenerateVideo = async () => {
    if (scenes.length === 0 || isRenderingVideo) return;
    
    // Reset video state for re-rendering
    setVideoUrl(null);
    setVideoFilename(null);
    setRenderProgress(0);
    
    setIsRenderingVideo(true);
    setRenderingMessage('Iniciando...');
    setError(null);
    
    try {
        const { url, filename } = await generateVideoFromScenes(
            scenes, 
            audioUrl, 
            videoResolution,
            (progress, message) => {
                setRenderProgress(progress);
                setRenderingMessage(message);
            }
        );
        setVideoUrl(url);
        setVideoFilename(filename);
    } catch (err) {
        console.error("Falha ao gerar o v√≠deo:", err);
        setError(err instanceof Error ? err.message : 'Falha ao gerar o v√≠deo.');
    } finally {
        setIsRenderingVideo(false);
        setRenderingMessage('');
    }
  };
  
  const isAnyActionInProgress = isZipping || isRenderingVideo || isBatchRegenerating;

  return (
    <div className="min-h-screen bg-gray-900 text-white font-sans">
      <Header />
      <main className="container mx-auto p-4 md:p-8 space-y-8">
        <InputForm onSubmit={handleGenerate} isLoading={isLoading} />

        <SceneDisplay
          scenes={scenes}
          isLoading={isLoading}
          loadingMessage={loadingMessage}
          error={error}
          onRegenerateScene={handleRegenerateScene}
          selectedScenes={selectedScenes}
          onSceneSelection={handleSceneSelection}
          onDeleteSceneImage={handleDeleteSceneImage}
          onUpdateSceneImage={handleUpdateSceneImage}
        />

        {!isLoading && scenes.length > 0 && (
          <div className="space-y-6">
             {selectedScenes.size > 0 && (
                 <div className="bg-gray-800/80 p-4 rounded-lg shadow-xl border border-indigo-500 sticky bottom-4 z-20 backdrop-blur-md">
                    <div className="flex flex-wrap justify-between items-center gap-4">
                        <p className="text-lg font-semibold">
                            {selectedScenes.size} cena(s) selecionada(s)
                        </p>
                        <div className="flex flex-wrap gap-2">
                            <button onClick={handleSelectAll} className="px-4 py-2 text-xs bg-gray-700 rounded hover:bg-gray-600">
                                {selectedScenes.size === scenes.length ? 'Limpar' : 'Todas'}
                            </button>
                            <button onClick={() => handleDownloadZip(selectedScenes)} disabled={isAnyActionInProgress} className="px-4 py-2 text-xs bg-green-600 rounded hover:bg-green-700">Baixar</button>
                             <button onClick={handleRegenerateSelected} disabled={isAnyActionInProgress} className="px-4 py-2 text-xs bg-indigo-600 rounded hover:bg-indigo-700">Regenerar</button>
                        </div>
                    </div>
                </div>
            )}

            <div className="bg-gray-800/50 p-6 rounded-lg shadow-md border border-gray-700 space-y-6">
                <h2 className="text-xl font-semibold text-center text-gray-300">Conclus√£o e Exporta√ß√£o</h2>
            
                {/* Export Section with Progress Bars */}
                <div className="max-w-3xl mx-auto space-y-6">
                    
                    {/* ZIP Generation UI */}
                    {isZipping ? (
                        <div className="bg-gray-900 p-6 rounded-xl border border-green-500/30 shadow-lg">
                            <div className="flex justify-between items-center mb-2">
                                <span className="text-green-400 font-bold animate-pulse">Preparando Arquivo ZIP...</span>
                                <span className="text-white font-mono">{zipProgress}%</span>
                            </div>
                            <div className="w-full bg-gray-700 rounded-full h-4 overflow-hidden mb-3">
                                <div 
                                    className="bg-gradient-to-r from-green-500 to-emerald-600 h-4 rounded-full transition-all duration-300 ease-out shadow-[0_0_15px_rgba(16,185,129,0.5)]" 
                                    style={{ width: `${zipProgress}%` }}
                                >
                                    <div className="w-full h-full opacity-30 bg-[length:20px_20px] bg-[linear-gradient(45deg,rgba(255,255,255,0.15)_25%,transparent_25%,transparent_50%,rgba(255,255,255,0.15)_50%,rgba(255,255,255,0.15)_75%,transparent_75%,transparent)] animate-stripes"></div>
                                </div>
                            </div>
                            <p className="text-xs text-gray-400 text-center font-mono">
                                {zipProgress < 50 ? 'Baixando imagens...' : 'Compactando arquivo...'}
                            </p>
                        </div>
                    ) : null}

                    {/* Video Generation UI */}
                    {isRenderingVideo ? (
                        <div className="bg-gray-900 p-6 rounded-xl border border-blue-500/30 shadow-lg">
                            <div className="flex justify-between items-center mb-2">
                                <span className="text-blue-400 font-bold animate-pulse">Renderizando V√≠deo...</span>
                                <span className="text-white font-mono">{renderProgress}%</span>
                            </div>
                            <div className="w-full bg-gray-700 rounded-full h-4 overflow-hidden mb-3">
                                <div 
                                    className="bg-gradient-to-r from-blue-600 to-purple-600 h-4 rounded-full transition-all duration-300 ease-out shadow-[0_0_15px_rgba(59,130,246,0.5)]" 
                                    style={{ width: `${renderProgress}%` }}
                                >
                                    <div className="w-full h-full opacity-30 bg-[length:20px_20px] bg-[linear-gradient(45deg,rgba(255,255,255,0.15)_25%,transparent_25%,transparent_50%,rgba(255,255,255,0.15)_50%,rgba(255,255,255,0.15)_75%,transparent_75%,transparent)] animate-stripes"></div>
                                </div>
                            </div>
                            <p className="text-xs text-gray-400 text-center font-mono">{renderingMessage}</p>
                        </div>
                    ) : null}


                    {/* Action Buttons (Only show if not processing) */}
                    {!isZipping && !isRenderingVideo && (
                         <div className="flex flex-wrap justify-center items-center gap-4">
                             {/* Bot√£o de Download ZIP */}
                             <button
                                onClick={() => handleDownloadZip()}
                                disabled={isAnyActionInProgress}
                                className="inline-flex items-center px-6 py-3 text-lg font-semibold text-white bg-green-600 rounded-md hover:bg-green-700 disabled:bg-gray-700 disabled:opacity-50 transition-all shadow-lg hover:shadow-green-900/20"
                              >
                                üì• Baixar Imagens (ZIP)
                              </button>

                            {/* Controles de V√≠deo */}
                            {!videoUrl ? (
                                <div className="flex items-center bg-gray-900 p-1 rounded-lg border border-gray-600">
                                    <select 
                                        value={videoResolution} 
                                        onChange={(e) => setVideoResolution(e.target.value as '720p' | '1080p')}
                                        className="bg-transparent text-white text-sm font-semibold px-3 py-2 outline-none cursor-pointer hover:text-blue-400 transition-colors"
                                    >
                                        <option value="720p">HD 720p</option>
                                        <option value="1080p">FHD 1080p</option>
                                    </select>
                                    <div className="w-px h-6 bg-gray-600 mx-1"></div>
                                    <button
                                        onClick={handleGenerateVideo}
                                        disabled={isAnyActionInProgress}
                                        className="px-6 py-2 text-lg font-bold text-white bg-blue-600 hover:bg-blue-700 rounded-md transition-all shadow-lg hover:shadow-blue-900/20 disabled:opacity-50"
                                    >
                                        üé¨ Renderizar V√≠deo
                                    </button>
                                </div>
                            ) : (
                                <div className="flex gap-3">
                                     <a
                                      href={videoUrl}
                                      download={videoFilename}
                                      className="inline-flex items-center px-6 py-3 text-lg font-semibold text-white bg-purple-600 rounded-md hover:bg-purple-700 shadow-lg transition-all animate-bounce-short"
                                    >
                                      üì• Baixar V√≠deo
                                    </a>
                                    <button
                                        onClick={() => setVideoUrl(null)} // Reset para permitir nova renderiza√ß√£o
                                        className="px-4 py-3 bg-gray-700 hover:bg-gray-600 rounded-md text-white font-semibold transition-all"
                                    >
                                        ‚Ü∫ Novo Render
                                    </button>
                                </div>
                            )}
                         </div>
                    )}
                </div>

                <div className="text-center space-y-2">
                     {isSrtSource && !isRenderingVideo && !videoUrl && (
                        <p className="text-xs text-gray-500">Sincroniza√ß√£o: <strong>Legenda SRT</strong></p>
                    )}
                     {audioUrl && !isRenderingVideo && !videoUrl && (
                        <p className="text-xs text-green-400">Sincroniza√ß√£o: <strong>√Åudio Detectado</strong> (A dura√ß√£o das cenas ser√° ajustada automaticamente)</p>
                    )}
                </div>
            </div>
          </div>
        )}
      </main>
      <footer className="text-center py-4 text-gray-500 text-sm">
        <p>Desenvolvido com IA do Google Gemini.</p>
      </footer>
       <style>{`
        @keyframes stripes {
            from { background-position: 40px 0; }
            to { background-position: 0 0; }
        }
        .animate-stripes {
            animation: stripes 1s linear infinite;
        }
        .animate-bounce-short {
            animation: bounce-short 1s;
        }
        @keyframes bounce-short {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }
      `}</style>
    </div>
  );
}

